/**
 * Prototype Line Generator - Main Entry Point
 * Generates React + Tailwind components from ViewForge configurations
 * 
 * Principle: "Make it real enough to get real feedback"
 */

const fs = require('fs');
const path = require('path');
const { validateConfiguration } = require('./validator');
const { parseConfiguration } = require('./parser');
const { generateTableView } = require('./generators/table-view');
const { generateTypes } = require('./generators/types');
const { generateMockData } = require('./generators/mock-data');

/**
 * Main generation function
 * @param {Object} config - ViewForge configuration JSON
 * @param {string} outputDir - Directory to write generated files
 * @returns {Object} Generated file paths
 */
function generatePrototype(config, outputDir) {
    // 1. Validate input
    const validation = validateConfiguration(config);
    if (!validation.valid) {
        throw new Error(`Invalid configuration: ${validation.errors.join(', ')}`);
    }
    
    // 2. Parse configuration
    const parsed = parseConfiguration(config);
    
    // 3. Create output directory structure
    const componentDir = path.join(outputDir, 'components');
    const typesDir = path.join(outputDir, 'types');
    const dataDir = path.join(outputDir, 'data');
    
    [componentDir, typesDir, dataDir].forEach(dir => {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    });
    
    // 4. Generate based on layout type
    const files = {};
    
    if (parsed.layout.type === 'table') {
        // Generate main view component
        const viewComponent = generateTableView(parsed);
        const viewPath = path.join(componentDir, `${parsed.componentName}View.tsx`);
        fs.writeFileSync(viewPath, viewComponent, 'utf8');
        files.viewComponent = viewPath;
    }
    
    // 5. Generate TypeScript types
    const types = generateTypes(parsed);
    const typesPath = path.join(typesDir, `${parsed.componentName}Types.ts`);
    fs.writeFileSync(typesPath, types, 'utf8');
    files.types = typesPath;
    
    // 6. Generate mock data
    const mockData = generateMockData(parsed);
    const dataPath = path.join(dataDir, `${parsed.componentName}MockData.ts`);
    fs.writeFileSync(dataPath, mockData, 'utf8');
    files.mockData = dataPath;
    
    // 7. Generate index file
    const indexContent = generateIndex(parsed, files);
    const indexPath = path.join(outputDir, 'index.tsx');
    fs.writeFileSync(indexPath, indexContent, 'utf8');
    files.index = indexPath;
    
    return files;
}

/**
 * Generate index file that exports all components
 */
function generateIndex(config, files) {
    return `/**
 * Generated by Prototype Line Generator
 * ${new Date().toISOString()}
 */

export { ${config.componentName}View } from './components/${config.componentName}View';
export type { ${config.entityNamePascal}, ${config.componentName}Props } from './types/${config.componentName}Types';
export { mock${config.entityNamePascal}Data } from './data/${config.componentName}MockData';

// Re-export for convenience
export { ${config.componentName}View as default } from './components/${config.componentName}View';
`;
}

// Export for use as module
module.exports = {
    generatePrototype
};

// CLI support
if (require.main === module) {
    const args = process.argv.slice(2);
    
    if (args.length < 2) {
        console.error('Usage: node index.js <config.json> <output-dir>');
        process.exit(1);
    }
    
    const configPath = args[0];
    const outputDir = args[1];
    
    try {
        const configJson = fs.readFileSync(configPath, 'utf8');
        const config = JSON.parse(configJson);
        const files = generatePrototype(config, outputDir);
        
        console.log('âœ“ Generated Prototype Line components:');
        Object.entries(files).forEach(([key, path]) => {
            console.log(`  - ${key}: ${path}`);
        });
    } catch (error) {
        console.error(`Error: ${error.message}`);
        process.exit(1);
    }
}