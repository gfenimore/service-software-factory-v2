/**
 * Work Orders Data Hook
 * Generated by HOOK-PROCESSOR
 * Purpose: Fetch and manage work orders for a service location
 */

'use client'

import { useState, useEffect, useCallback } from 'react'
import type { WorkOrder, UseWorkOrdersReturn } from '@/types/workOrder.types'
import { generateMockWorkOrders } from '@/lib/mock/workOrderMocks'

/**
 * Hook to fetch work orders for a specific service location
 * Currently uses mock data - will be updated to use Supabase in production
 */
export function useWorkOrders(locationId: string): UseWorkOrdersReturn {
  const [workOrders, setWorkOrders] = useState<WorkOrder[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchWorkOrders = useCallback(async () => {
    // Reset state
    setLoading(true)
    setError(null)

    try {
      // Handle empty location ID
      if (!locationId) {
        setWorkOrders([])
        setLoading(false)
        return
      }

      // Simulate API delay for realistic loading experience
      await new Promise((resolve) => setTimeout(resolve, 300))

      // Try to fetch from Supabase first
      try {
        // Import Supabase client
        const { createClient } = await import('@/lib/supabase/client')
        const supabase = createClient()

        const { data, error } = await supabase
          .from('work_orders')
          .select('*')
          .eq('service_location_id', locationId)
          .order('priority', { ascending: true })
          .order('scheduled_date', { ascending: false })

        if (error) throw error

        if (data && data.length > 0) {
          console.log(`Fetched ${data.length} work orders from database for location ${locationId}`)
          setWorkOrders(data)
          setLoading(false)
          return
        }
      } catch (dbError) {
        console.log('Database fetch failed, using mock data:', dbError)
      }

      // Fall back to mock data if database is not available
      const mockData = generateMockWorkOrders(locationId, 20)
      console.log(`Generated ${mockData.length} mock work orders for location ${locationId}`)
      setWorkOrders(mockData)
      setLoading(false)
    } catch (err) {
      console.error('Error fetching work orders:', err)
      setError(err instanceof Error ? err.message : 'Failed to fetch work orders')
      setWorkOrders([])
      setLoading(false)
    }
  }, [locationId])

  // Fetch work orders when location changes
  useEffect(() => {
    fetchWorkOrders()
  }, [fetchWorkOrders])

  // Refetch function for manual refresh
  const refetch = useCallback(() => {
    fetchWorkOrders()
  }, [fetchWorkOrders])

  return {
    workOrders,
    loading,
    error,
    refetch,
  }
}

/**
 * Hook to fetch a single work order by ID
 * Useful for detail views
 */
export function useWorkOrder(workOrderId: string | null): {
  workOrder: WorkOrder | null
  loading: boolean
  error: string | null
} {
  const [workOrder, setWorkOrder] = useState<WorkOrder | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (!workOrderId) {
      setWorkOrder(null)
      return
    }

    const fetchWorkOrder = async () => {
      setLoading(true)
      setError(null)

      try {
        // Simulate API delay
        await new Promise((resolve) => setTimeout(resolve, 200))

        // TODO: Replace with Supabase query
        // const { data, error } = await supabase
        //   .from('work_orders')
        //   .select('*')
        //   .eq('id', workOrderId)
        //   .single();

        // Mock implementation - generate a single work order
        const mockOrders = generateMockWorkOrders('temp-location', 1)
        const foundOrder = { ...mockOrders[0], id: workOrderId }

        setWorkOrder(foundOrder)
        setLoading(false)
      } catch (err) {
        console.error('Error fetching work order:', err)
        setError(err instanceof Error ? err.message : 'Failed to fetch work order')
        setLoading(false)
      }
    }

    fetchWorkOrder()
  }, [workOrderId])

  return { workOrder, loading, error }
}
