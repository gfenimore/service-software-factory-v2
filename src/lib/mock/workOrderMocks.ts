/**
 * Work Order Mock Data Generator
 * Generated by MOCK-PROCESSOR
 * Purpose: Provide realistic work order data for development without database dependency
 */

import type {
  WorkOrder,
  WorkOrderStatus,
  WorkOrderType,
  WorkOrderPriority,
} from '@/types/workOrder.types'

const statuses: WorkOrderStatus[] = [
  'Scheduled',
  'Assigned',
  'In-Progress',
  'Completed',
  'Invoiced',
]
const types: WorkOrderType[] = ['Maintenance', 'Repair', 'Installation', 'Inspection']
const priorities: WorkOrderPriority[] = ['Low', 'Medium', 'High', 'Emergency']

const technicianNames = [
  'John Smith',
  'Sarah Johnson',
  'Mike Williams',
  'Emily Davis',
  'Robert Brown',
  'Lisa Anderson',
  'David Martinez',
  'Jennifer Wilson',
]

const timeSlots = [
  'Morning (8AM-12PM)',
  'Afternoon (12PM-5PM)',
  'Evening (5PM-8PM)',
  'Emergency (24/7)',
]

const descriptions = {
  Maintenance: [
    'Routine HVAC system maintenance',
    'Monthly equipment inspection',
    'Preventive maintenance check',
    'Filter replacement and cleaning',
  ],
  Repair: [
    'Fix leaking pipe in bathroom',
    'Repair malfunctioning equipment',
    'Replace broken window',
    'Fix electrical outlet issue',
  ],
  Installation: [
    'Install new security system',
    'Set up network equipment',
    'Install emergency lighting',
    'Mount new display monitors',
  ],
  Inspection: [
    'Annual safety inspection',
    'Fire system compliance check',
    'Building code inspection',
    'Equipment certification review',
  ],
}

export function generateMockWorkOrders(locationId: string, count: number = 15): WorkOrder[] {
  if (!locationId) return []

  const workOrders: WorkOrder[] = []
  const baseDate = new Date()

  for (let i = 0; i < count; i++) {
    const type = types[Math.floor(Math.random() * types.length)]
    const status = statuses[Math.floor(Math.random() * statuses.length)]
    const priority = priorities[Math.floor(Math.random() * priorities.length)]

    // Emergency items are always high priority
    const adjustedPriority =
      status === 'In-Progress' && Math.random() > 0.7 ? 'Emergency' : priority

    // Completed items should have completion notes
    const hasCompletionNotes = status === 'Completed' || status === 'Invoiced'

    // Assigned and In-Progress should have technicians
    const hasTechnician =
      status === 'Assigned' ||
      status === 'In-Progress' ||
      status === 'Completed' ||
      status === 'Invoiced'

    // Calculate scheduled date (past for completed, future for scheduled)
    const daysOffset =
      status === 'Completed' || status === 'Invoiced'
        ? -Math.floor(Math.random() * 30) // Past 30 days
        : Math.floor(Math.random() * 30) // Next 30 days

    const scheduledDate = new Date(baseDate)
    scheduledDate.setDate(scheduledDate.getDate() + daysOffset)

    const workOrder: WorkOrder = {
      id: `wo-${locationId}-${i + 1}`,
      service_location_id: locationId,
      work_order_number: `WO-2025-${String(1000 + i).padStart(4, '0')}`,
      type,
      status,
      priority: adjustedPriority,
      scheduled_date: scheduledDate.toISOString().split('T')[0],
      scheduled_time_slot:
        adjustedPriority === 'Emergency' ? timeSlots[3] : timeSlots[Math.floor(Math.random() * 3)],
      technician_id: hasTechnician ? `tech-${Math.floor(Math.random() * 8) + 1}` : undefined,
      technician_name: hasTechnician
        ? technicianNames[Math.floor(Math.random() * technicianNames.length)]
        : undefined,
      description: descriptions[type][Math.floor(Math.random() * descriptions[type].length)],
      completion_notes: hasCompletionNotes
        ? `Work completed successfully. ${type === 'Inspection' ? 'All systems passed inspection.' : 'No issues found.'}`
        : undefined,
      created_at: new Date(
        baseDate.getTime() - Math.random() * 90 * 24 * 60 * 60 * 1000
      ).toISOString(),
      updated_at: new Date().toISOString(),
    }

    workOrders.push(workOrder)
  }

  // Sort by scheduled date (newest first) and priority
  return workOrders.sort((a, b) => {
    // First sort by priority (Emergency first)
    const priorityOrder = { Emergency: 0, High: 1, Medium: 2, Low: 3 }
    const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority]
    if (priorityDiff !== 0) return priorityDiff

    // Then by scheduled date
    return new Date(b.scheduled_date).getTime() - new Date(a.scheduled_date).getTime()
  })
}

// Generate sample data for testing
export const sampleWorkOrders = generateMockWorkOrders('sample-location-123', 5)
